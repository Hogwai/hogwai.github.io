---
title: |
    Lombok: Convenient annotations until they aren't (WIP)
description: 'Some Lombok annotations do not have your best interests at heart. Learn how to avoid undesirable behaviors and side effects'
pubDate: 2025-10-25
tags: ['java', 'spring-boot', 'spring-data-jpa', 'hibernate', 'lombok', 'annotation']
draft: false
---

Lombok has been and remains a gift for Java developers.
IIt frees us from the burden of writing tedious, repetitive code, making our classes cleaner, more readable, and easier to maintain.

But as with any powerful tool, convenience can sometimes hide subtle dangers. When Lombok meets the world of JPA (Java Persistence API) and Spring, a few annotations can lead to unexpected behaviors and frustrating issues.

## The Safe Zone

### `@Getter` and `@Setter`

These are the bread and butter of Lombok. Java Beans relies heavily on standard getters and setters to access and mutate their state. Whether you're using field or property access, Lombok-generated getters and setters are indistinguishable from hand-written ones.

They are simple, direct, and don't trigger any complex behavior.

```java
@Entity
@Getter
@Setter
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    private String email;
}
```

### `@Builder`

The Builder pattern is fantastic for constructing complex objects and `@Builder` makes it really easy.
Again, using a builder is safe and doesn't interfere with the persistence lifecycle nor the state of an entity.

```java
@Entity
@Getter
@Builder
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private BigDecimal price;
}
```

## The Gray Zone

### The `@AllArgsConstructor` Pitfall

A common (but incorrect) pattern is to use `@AllArgsConstructor` on a Spring `@Service` or `@Component` to let Spring inject dependencies via the constructor.

```java
@Service
@AllArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
}
```

The example above works well...
HOWEVER
the issue with `@AllArgsConstructor` is that it can not tell the difference between different types of attributes:

```java
@Service
@AllArgsConstructor
public class UserService {
    @Value("${property}")
    private String springManagedProperty;
    private final UserRepository userRepository;
    private final EmailService emailService;
}
```

In this example, we have two dependancies and a simple attribute managed by Spring.
`springManagedProperty` will be null because the `@Value` annotation is bypassed by the constructor injection generated by Lombok.

#### A more robust way: `@RequiredArgsConstructor`

A safer way is to use `@RequiredArgsConstructor` with `final` fields.

```java
@Service
@RequiredArgsConstructor
public class UserService {
    @Value("${property}")
    private String springManagedProperty;
    private final UserRepository userRepository;
    private final EmailService emailService;
}
```

This approach is better for several reasons:

1. **Safety:** It only generates a constructor for the `final` fields, which are your mandatory dependencies. Everything else remains untouched.
2. **Immutability:** Using `final` fields promotes good design and thread safety.
3. **Spring Compatibility:** It works perfectly with Spring's constructor injection, which is the recommended injection method.

#### The best way (in my humble opinion)

Lombok doesn't have to be 'all-or-nothing'.
Constructor injection is a standard and sometimes a bit of boilerplate code doesn't hurt.

```java
@Service
public class UserService {
    @Value("${property}")
    private String springManagedProperty;
    private final UserRepository userRepository;
    private final EmailService emailService;

    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
}
```

## The Danger Zone: More Than Just `@ToString`

The `@ToString` annotation is the most famous culprit, but the real danger often comes from shortcuts that bundle it in.

### The `@Data` Trap: An All-in-One Problem

`@Data` is one of Lombok's most popular annotations. It's a convenient shortcut that bundles together `@Getter`, `@Setter`, `@RequiredArgsConstructor`, `@ToString`, and `@EqualsAndHashCode`.

And that's precisely the problem. By putting `@Data` on a JPA entity, you are *implicitly* and *unintentionally* applying all the risks of `@ToString` and `@EqualsAndHashCode` (which suffers from the same lazy-loading issues) to your class.

**AVOID THIS:**

```java
@Entity
@Data // This is a trap! It includes @ToString and @EqualsAndHashCode
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;

    @OneToMany(fetch = FetchType.LAZY)
    private List<Post> posts = new ArrayList<>();
}
```

While `@Data` is fantastic for simple DTOs or value objects, it is a **code smell on JPA entities**. It's better to be explicit and only apply the annotations you truly need and have considered.

### The Perils of `@ToString`

Let's break down why `@ToString` is so problematic on entities.

#### Problem 1: The Stack Overflow Nightmare (Bidirectional Relationships)

This is the most classic issue. Imagine a standard bidirectional relationship: a `User` has many `Post`s, and each `Post` belongs to a `User`.

```java
// AVOID THIS!
@Entity
@ToString // DANGER!
public class User {
    // ...
    @OneToMany(mappedBy = "user")
    private List<Post> posts = new ArrayList<>();
}

// AVOID THIS!
@Entity
@ToString // DANGER!
public class Post {
    // ...
    @ManyToOne
    private User user;
}
```

When you call `user.toString()`, it calls `posts.toString()`, which calls `post.toString()`, which calls `user.toString()`... creating an infinite recursion that crashes your application with a `StackOverflowError`.

#### Problem 2: The Lazy Loading Surprise (Performance Killer)

Even without a bidirectional relationship, `@ToString` can be a major performance problem. JPA's lazy loading means that associations are not loaded from the database until you access them. Lombok's `toString()` method will access *all* fields, triggering lazy loads unexpectedly.

```java
// AVOID THIS!
@Entity
@ToString // DANGER!
public class User {
    // ...
    @OneToMany(fetch = FetchType.LAZY)
    private List<Post> posts = new ArrayList<>();
}
```

```java
@Transactional
public void findUserAndLog() {
    User user = userRepository.findById(1L).get(); // 'posts' is a proxy
    // This innocent line triggers a new SQL query to load all posts!
    System.out.println("Logging user: " + user); 
}
```

This can lead to:

1. **Unexpected Database Hits:** Your simple logging statement is now hitting the database.
2. **N+1 Query Problem:** Doing this in a loop can generate hundreds of extra queries.
3. **LazyInitializationException:** If you call `toString()` outside a transactional context, the session is closed, and Hibernate will throw an exception.

## The Solutions: How to Use Lombok Safely

So, how do we use Lombok without falling into these traps?

### Solution 1: Be Explicit, Avoid `@Data` on Entities

Instead of `@Data`, be explicit. Use only the annotations you need.

```java
@Entity
@Getter
@RequiredArgsConstructor // For the mandatory fields like @Id
@ToString(exclude = "posts") // Be explicit about toString
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private final Long id; // final works great with @RequiredArgsConstructor

    private String username;

    @OneToMany(fetch = FetchType.LAZY)
    private List<Post> posts = new ArrayList<>();
}
```

### Solution 2: Exclude Problematic Fields from `@ToString`

As shown above, use `@ToString.Exclude` to prevent lazy loading and recursion.

```java
@Entity
@Getter
@ToString
public class Post {
    // ...
    @ManyToOne
    @ToString.Exclude // Prevents the back-reference recursion
    private User user;
}
```

### Solution 3: Use `@RequiredArgsConstructor` for Dependency Injection

Always prefer `@RequiredArgsConstructor` with `final` fields for your Spring beans over `@AllArgsConstructor`.

## Conclusion

Lombok is an incredible tool, but in the complex worlds of persistence and dependency injection, you must wield it with care.

* **Safe:** `@Getter`, `@Setter`, and `@Builder` are generally safe and beneficial.
* **Dangerous on Entities:** `@ToString` and `@EqualsAndHashCode` are risky due to lazy loading and bidirectional relationships. **Avoid `@Data` on JPA entities** as it bundles these risks implicitly.
* **Dangerous for DI:** `@AllArgsConstructor` can break the Spring container's contract. **Prefer `@RequiredArgsConstructor` with `final` fields** for dependency injection.

The golden rule is:
**Be deliberate.**

Understand what each Lombok annotation does under the hood. By being explicit and choosing the right tool for the job, you can keep your code clean, concise, and, most importantly, bug-free

## References

1. <a id="ref1"></a>[String.matches(String regex)](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html#matches(java.lang.String))
2. <a id="ref2"></a>[RegExUtils.java](https://github.com/apache/commons-lang/blob/master/src/main/java/org/apache/commons/lang3/RegExUtils.java)
